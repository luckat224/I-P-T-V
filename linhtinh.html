<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to Image Upload</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-wrapper {
            position: relative;
            border: 3px dashed #ddd;
            border-radius: 10px;
            padding: 10px;
            transition: all 0.3s;
        }

        .input-wrapper.drag-over {
            border-color: #4CAF50;
            background-color: #f0fff0;
        }

        .upload-hint {
            text-align: center;
            color: #999;
            padding: 10px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .upload-hint strong {
            color: #666;
        }

        .file-input-wrapper {
            text-align: center;
            margin-bottom: 10px;
        }

        .btn-choose-file {
            background-color: #FF9800;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            display: inline-block;
        }

        .btn-choose-file:hover {
            background-color: #e68900;
        }

        input[type="file"] {
            display: none;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 5px;
            resize: vertical;
            font-family: Arial, sans-serif;
        }

        textarea:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .preview-section {
            margin-bottom: 30px;
        }

        #preview {
            width: 100%;
            min-height: 300px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            color: black;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 150px;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-preview {
            background-color: #2196F3;
            color: white;
        }

        .btn-preview:hover {
            background-color: #0b7dda;
        }

        .btn-upload {
            background-color: #4CAF50;
            color: white;
        }

        .btn-upload:hover {
            background-color: #45a049;
        }

        .btn-upload:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .result-section {
            display: none;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 2px solid #4CAF50;
        }

        .result-section.show {
            display: block;
        }

        .result-section h3 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .link-container {
            background: white;
            padding: 15px;
            border-radius: 5px;
            word-break: break-all;
            margin-bottom: 10px;
        }

        .link-container a {
            color: #2196F3;
            text-decoration: none;
            font-weight: bold;
        }

        .link-container a:hover {
            text-decoration: underline;
        }

        .btn-copy {
            background-color: #FF9800;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-copy:hover {
            background-color: #e68900;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            display: none;
            padding: 15px;
            background-color: #ffebee;
            color: #c62828;
            border-radius: 5px;
            margin-top: 15px;
        }

        .error.show {
            display: block;
        }

        canvas {
            display: none;
        }
        /* Tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 18px;
        }

        .tab-btn {
            padding: 10px 16px;
            background: #eee;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .tab-btn.active {
            background: #2196F3;
            color: white;
            border-color: #1976d2;
        }

        .tab-panel { display: none; }
        .tab-panel.show { display: block; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìù Text to Image Upload</h1>
        <div class="tabs" role="tablist">
            <button class="tab-btn active" id="tabBtn1" onclick="openTab(1)">Text / Image</button>
            <button class="tab-btn" id="tabBtn2" onclick="openTab(2)">Normalize Form</button>
            <button class="tab-btn" id="tabBtn3" onclick="openTab(3)">Check k√™nh IPTV</button>
        </div>
        
        <div class="input-section tab-panel show" id="tabPanel1">
            <h3>Nh·∫≠p ho·∫∑c d√°n vƒÉn b·∫£n c·ªßa b·∫°n:</h3>
            <div class="input-wrapper" id="inputWrapper">
                <div class="upload-hint">
                    <strong>üí° M·∫πo:</strong> K√©o th·∫£ h√¨nh ·∫£nh v√†o ƒë√¢y, ho·∫∑c click n√∫t b√™n d∆∞·ªõi ƒë·ªÉ ch·ªçn file
                </div>
                <div class="file-input-wrapper">
                    <label for="fileInput" class="btn-choose-file">üìÅ Ch·ªçn h√¨nh ·∫£nh t·ª´ m√°y</label>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                <textarea id="textInput" placeholder="Ho·∫∑c d√°n vƒÉn b·∫£n c·ªßa b·∫°n v√†o ƒë√¢y..."></textarea>
            </div>
        </div>

        <!-- Normalize Form tab -->
        <div class="input-section tab-panel" id="tabPanel2">
            <h3>ƒê∆∞a ƒëo·∫°n vƒÉn b·∫£n sai form v·ªÅ form chu·∫©n:</h3>
            <div class="input-wrapper">
                <textarea id="normalizeInput" placeholder="D√°n ƒëo·∫°n vƒÉn b·∫£n c·∫ßn chu·∫©n ho√° v√†o ƒë√¢y..."></textarea>
            </div>
            <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
                <button class="btn-upload" id="normalizeBtn" onclick="runNormalize()">üîß Chuy·ªÉn v·ªÅ form chu·∫©n</button>
                <button class="btn-choose-file" onclick="copyNormalized()">üìã Sao ch√©p k·∫øt qu·∫£</button>
                <label style="margin-left:12px; font-weight:normal;"><input type="checkbox" id="smartRemove" checked> X√≥a heading th√¥ng minh (I., PH·∫¶N, ti√™u ƒë·ªÅ in hoa)</label>
                <!-- AI integration removed: single-file now without AI -->
            </div>
            <div style="margin-top:8px; color:#666;">API key ƒë√£ ƒë∆∞·ª£c t√≠ch h·ª£p tr·ª±c ti·∫øp trong file (private mode).</div>
            <div style="margin-top:12px;">
                <h4>K·∫øt qu·∫£ chu·∫©n ho√°: <small style="font-weight:normal;color:#666;">(B·∫°n c√≥ th·ªÉ s·ª≠a tr·ª±c ti·∫øp ·ªü ƒë√¢y)</small></h4>
                <div id="normalizedResult" contenteditable="true" role="textbox" aria-label="K·∫øt qu·∫£ chu·∫©n ho√° - c√≥ th·ªÉ s·ª≠a" 
                     style="white-space:pre-wrap;padding:12px;border:2px solid #ddd;border-radius:6px;background:#fff;min-height:120px;outline:none;">
                </div>
            </div>
        </div>

        <!-- Check k√™nh IPTV tab -->
        <div class="input-section tab-panel" id="tabPanel3">
            <h3>Check k√™nh IPTV</h3>
            <!-- We'll load index.html into this iframe via srcdoc with sandbox to isolate from browser extensions -->
            <iframe id="iptvFrame" title="Check k√™nh IPTV" sandbox="allow-scripts allow-same-origin allow-forms" style="width:100%;height:720px;border:1px solid #ddd;border-radius:6px;">
                <!-- fallback content -->
                <p style="padding:12px;">Loading IPTV checker‚Ä¶</p>
            </iframe>
            <div id="iptvLoadError" style="display:none;color:#b00020;margin-top:8px;font-size:13px;"></div>
        </div>


        <div class="button-group">
            <button class="btn-upload" id="uploadBtn" onclick="convertAndUpload()" disabled>üì§ Chuy·ªÉn ƒë·ªïi & Upload</button>
        </div>

        <div class="preview-section">
            <div id="preview">VƒÉn b·∫£n c·ªßa b·∫°n s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y</div>
        </div>

        <canvas id="canvas"></canvas>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>ƒêang upload ·∫£nh...</p>
        </div>

        <div class="error" id="error"></div>

        <div class="result-section" id="result">
            <h3>‚úÖ Upload th√†nh c√¥ng!</h3>
            <div class="link-container">
                <strong>Link ·∫£nh:</strong><br>
                <a id="imageLink" href="#" target="_blank"></a>
            </div>
            <button class="btn-copy" onclick="copyLink()">üìã Sao ch√©p link</button>
        </div>
    </div>

        <!-- Conversion history -->
        <div class="history-section" id="historySection" style="margin-top:18px;">
            <h3>L·ªãch s·ª≠ chuy·ªÉn ƒë·ªïi</h3>
            <div id="historyList" style="display:flex;flex-direction:column;gap:8px;">
                <!-- entries appended here -->
            </div>
        </div>

    <script>

    // AI integration removed ‚Äî no client key in this file.


        // ƒê·∫£m b·∫£o DOM ƒë√£ ƒë∆∞·ª£c t·∫£i xong
        document.addEventListener('DOMContentLoaded', function() {
            initApp();
            // Auto-enable smartRemove by default (user can uncheck)
            try {
                const smartEl = document.getElementById('smartRemove');
                if (smartEl) smartEl.checked = true;
            } catch (e) {
                console.warn('Auto-init failed', e);
            }
        });


        let currentText = '';
        let uploadedImageBlob = null;
        let uploadedImageDataUrl = null;

        function initApp() {
            const textInput = document.getElementById('textInput');
            const uploadBtn = document.getElementById('uploadBtn');
            const fileInput = document.getElementById('fileInput');
            const inputWrapper = document.getElementById('inputWrapper');
            const preview = document.getElementById('preview');

            // Tab default
            openTab(1);

            // Paste support for images (Ctrl+V)
            if (textInput) {
                textInput.addEventListener('paste', function(e) {
                    handlePasteEvent(e);
                });
            }

            // Normalize input: allow Ctrl+V as well (no special image handling here)
            const normalizeInput = document.getElementById('normalizeInput');
            if (normalizeInput) {
                normalizeInput.addEventListener('paste', function(e){
                    // allow default paste for text
                });
            }

            // L·∫Øng nghe s·ª± ki·ªán nh·∫≠p vƒÉn b·∫£n
            if (textInput) {
                textInput.addEventListener('input', function(e) {
                    currentText = e.target.value;
                    updatePreview();
                    uploadBtn.disabled = currentText.trim() === '' && !uploadedImageBlob;
                });
            }

            // X·ª≠ l√Ω ch·ªçn file
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file && file.type.startsWith('image/')) {
                        handleImageFile(file);
                    }
                });
            }

            // X·ª≠ l√Ω k√©o th·∫£
            if (inputWrapper) {
                inputWrapper.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    inputWrapper.classList.add('drag-over');
                });

                inputWrapper.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    inputWrapper.classList.remove('drag-over');
                });

                inputWrapper.addEventListener('drop', function(e) {
                    e.preventDefault();
                    inputWrapper.classList.remove('drag-over');
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].type.startsWith('image/')) {
                        handleImageFile(files[0]);
                    }
                });
            }
        }

        // Tab switcher
        let _iptvLoaded = false;
        function openTab(n) {
            const panels = document.querySelectorAll('.tab-panel');
            panels.forEach((p, i) => {
                if (i === n-1) p.classList.add('show'); else p.classList.remove('show');
            });
            document.getElementById('tabBtn1').classList.toggle('active', n===1);
            document.getElementById('tabBtn2').classList.toggle('active', n===2);
            // Support third tab (Check k√™nh IPTV)
            const tb3 = document.getElementById('tabBtn3');
            if (tb3) tb3.classList.toggle('active', n===3);

            // Lazy-load the IPTV iframe content once when opening tab 3
            if (n === 3 && !_iptvLoaded) {
                loadIptvIntoFrame();
            }
        }

        // Load index.html into the IPTV iframe via srcdoc with sandboxing to isolate from browser extensions
        async function loadIptvIntoFrame() {
            const frame = document.getElementById('iptvFrame');
            const errEl = document.getElementById('iptvLoadError');
            if (!frame) return;
            try {
                const res = await fetch('./index.html');
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const html = await res.text();
                // Use sandbox attribute to prevent extension scripts from interfering
                frame.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms');
                frame.srcdoc = html;
                _iptvLoaded = true;
            } catch (e) {
                console.error('Failed to load index.html into iframe:', e);
                if (errEl) {
                    errEl.style.display = 'block';
                    errEl.textContent = 'Kh√¥ng th·ªÉ t·∫£i n·ªôi dung IPTV: ' + e.message + '. Vui l√≤ng ƒë·∫£m b·∫£o index.html n·∫±m trong c√πng th∆∞ m·ª•c.';
                }
                // Fallback: try direct src approach
                try {
                    frame.src = './index.html';
                    _iptvLoaded = true;
                } catch (e2) {
                    console.error('Fallback also failed:', e2);
                }
            }
        }

        // Handle paste event: check for images in clipboard
        function handlePasteEvent(e) {
            if (!e.clipboardData) return;
            const items = e.clipboardData.items;
            if (!items) return;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type && item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    if (blob) {
                        handleImageFile(blob);
                        // Prevent image being pasted as inline base64 into textarea
                        e.preventDefault();
                        return;
                    }
                }
            }
            // otherwise allow default paste
        }

        // X·ª≠ l√Ω file h√¨nh ·∫£nh

        function handleImageFile(file) {
            uploadedImageBlob = file;
            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedImageDataUrl = e.target.result;
                updatePreview();
                document.getElementById('uploadBtn').disabled = false;
            };
            reader.readAsDataURL(file);
        }

        // T·ª± ƒë·ªông c·∫≠p nh·∫≠t preview
        function updatePreview() {
            const preview = document.getElementById('preview');
            const text = currentText.trim();
            // Hi·ªÉn th·ªã text ·ªü tr√™n, ·∫£nh ·ªü d∆∞·ªõi n·∫øu c√≥ c·∫£ hai
            if (uploadedImageDataUrl && text) {
                preview.innerHTML = `<div style='margin-bottom:16px; font-size:32px; font-weight:bold; color:black; word-break:break-word;'>${escapeHtml(text).replace(/\n/g,'<br>')}</div><div><img src="${uploadedImageDataUrl}" style="max-width: 100%; max-height: 400px; object-fit: contain;"></div>`;
            } else if (uploadedImageDataUrl) {
                preview.innerHTML = `<img src="${uploadedImageDataUrl}" style="max-width: 100%; max-height: 400px; object-fit: contain;">`;
            } else if (text) {
                preview.innerHTML = `<div style='font-size:32px; font-weight:bold; color:black; word-break:break-word;'>${escapeHtml(text).replace(/\n/g,'<br>')}</div>`;
            } else {
                preview.textContent = 'VƒÉn b·∫£n c·ªßa b·∫°n s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y';
            }
        }

        // Escape HTML ƒë·ªÉ tr√°nh l·ªói khi hi·ªÉn th·ªã text
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        // Chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n th√†nh ·∫£nh
        function textToImage(text) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Basic font settings (can adjust if you want higher resolution)
            let fontSize = 32;
            const fontFamily = 'Arial, sans-serif';
            const fontWeight = 'normal';

            // Prepare lines by temporarily setting font
            ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;

            // We'll wrap by words; pick a reasonable canvas width and padding
            const padding = 40;
            const canvasWidth = 1920; // wide enough for most cases
            const maxHeight = 12000; // safety cap to avoid runaway memory

            // Helper to build lines given current font
            function buildLines() {
                ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
                const maxWidth = canvasWidth - padding * 2;
                const words = text.split(/\s+/).filter(w => w.length>0);
                const lines = [];
                if (words.length === 0) return lines;
                let currentLine = words[0];
                for (let i = 1; i < words.length; i++) {
                    const testLine = currentLine + ' ' + words[i];
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth) {
                        lines.push(currentLine);
                        currentLine = words[i];
                    } else {
                        currentLine = testLine;
                    }
                }
                lines.push(currentLine);
                return lines;
            }

            let lines = buildLines();

            // If resulting canvas would be too tall, reduce fontSize until it fits under maxHeight
            let lineHeight = Math.round(fontSize * 1.4);
            let canvasHeight = padding * 2 + lines.length * lineHeight;
            while (canvasHeight > maxHeight && fontSize > 10) {
                fontSize = Math.max(10, Math.floor(fontSize * 0.9));
                lines = buildLines();
                lineHeight = Math.round(fontSize * 1.4);
                canvasHeight = padding * 2 + lines.length * lineHeight;
            }

            // Finally set canvas size to fit text
            canvas.width = canvasWidth;
            canvas.height = Math.min(canvasHeight, maxHeight);

            // Draw background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw text
            ctx.fillStyle = 'black';
            ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';

            // Render each line left-aligned with padding
            for (let i = 0; i < lines.length; i++) {
                const y = padding + i * lineHeight;
                // Truncate lines that would render beyond canvas height
                if (y + lineHeight > canvas.height) break;
                ctx.fillText(lines[i], padding, y);
            }

            return canvas;
        }

        // Chuy·ªÉn ƒë·ªïi canvas th√†nh blob
        function canvasToBlob(canvas) {
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    resolve(blob);
                }, 'image/jpeg', 1.0); // Ch·∫•t l∆∞·ª£ng t·ªëi ƒëa
            });
        }

        // Upload ·∫£nh l√™n API
        async function uploadImage(blob) {
            const formData = new FormData();
            formData.append('images[]', blob, 'text-image.jpg');
            formData.append('server', 'server_1');
            
            const response = await fetch('https://cfig.ibytecdn.org/upload', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error('Upload failed: ' + response.statusText);
            }
            
            const result = await response.json();
            console.log('API Response:', result); // Debug: xem response t·ª´ server
            return result;
        }

        // Ch·ª©c nƒÉng ch√≠nh: Chuy·ªÉn ƒë·ªïi v√† upload

        async function convertAndUpload() {
            // N·∫øu c√≥ ·∫£nh th√¨ upload ·∫£nh, n·∫øu kh√¥ng th√¨ upload text th√†nh ·∫£nh
            if (uploadedImageBlob) {
                await uploadDirectImage();
            } else {
                await uploadTextAsImage();
            }
        }

        // Upload h√¨nh ·∫£nh tr·ª±c ti·∫øp
        async function uploadDirectImage() {
            // ·∫®n k·∫øt qu·∫£ c≈© v√† hi·ªÉn th·ªã loading
            document.getElementById('result').classList.remove('show');
            document.getElementById('error').classList.remove('show');
            document.getElementById('loading').classList.add('show');
            document.getElementById('uploadBtn').disabled = true;
            
            try {
                console.log('Uploading image directly:', uploadedImageBlob);
                
                // Upload ·∫£nh
                const result = await uploadImage(uploadedImageBlob);
                
                console.log('Upload result:', result);
                
                displayUploadResult(result);
                
            } catch (error) {
                console.error('Error:', error);
                showError('C√≥ l·ªói x·∫£y ra: ' + error.message);
            } finally {
                document.getElementById('loading').classList.remove('show');
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        // Upload vƒÉn b·∫£n d∆∞·ªõi d·∫°ng ·∫£nh
        async function uploadTextAsImage() {
            // Prefer the normalized/edited result if present (user may have edited it)
            const normEl = document.getElementById('normalizedResult');
            let text = '';
            if (normEl && normEl.textContent && normEl.textContent.trim().length > 0) {
                text = normEl.textContent.trim();
            } else {
                text = document.getElementById('textInput').value.trim();
            }

            if (text === '') {
                showError('Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ho·∫∑c ch·ªçn h√¨nh ·∫£nh!');
                return;
            }
            
            // ·∫®n k·∫øt qu·∫£ c≈© v√† hi·ªÉn th·ªã loading
            document.getElementById('result').classList.remove('show');
            document.getElementById('error').classList.remove('show');
            document.getElementById('loading').classList.add('show');
            document.getElementById('uploadBtn').disabled = true;
            
            try {
                // Chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n th√†nh ·∫£nh
                const canvas = textToImage(text);
                const blob = await canvasToBlob(canvas);
                
                console.log('Image blob created:', blob); // Debug
                
                // Upload ·∫£nh
                const result = await uploadImage(blob);
                
                console.log('Upload result:', result); // Debug
                
                displayUploadResult(result);
                
            } catch (error) {
                console.error('Error:', error);
                showError('C√≥ l·ªói x·∫£y ra: ' + error.message);
            } finally {
                document.getElementById('loading').classList.remove('show');
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        // Hi·ªÉn th·ªã k·∫øt qu·∫£ upload
        function displayUploadResult(result) {
            // X·ª≠ l√Ω nhi·ªÅu ƒë·ªãnh d·∫°ng response kh√°c nhau
            let imageUrl = null;
            
            // Th·ª≠ nhi·ªÅu c√°ch parse response
            if (result) {
                // C√°ch 1: result.results[0].url (API n√†y d√πng)
                if (result.results && Array.isArray(result.results) && result.results.length > 0) {
                    imageUrl = result.results[0].url || result.results[0].link || result.results[0].src;
                }
                // C√°ch 2: result.data[0].url
                else if (result.data && Array.isArray(result.data) && result.data.length > 0) {
                    imageUrl = result.data[0].url || result.data[0].link || result.data[0].src;
                }
                // C√°ch 3: result.url tr·ª±c ti·∫øp
                else if (result.url) {
                    imageUrl = result.url;
                }
                // C√°ch 4: result.link
                else if (result.link) {
                    imageUrl = result.link;
                }
                // C√°ch 5: result[0] n·∫øu result l√† array
                else if (Array.isArray(result) && result.length > 0) {
                    imageUrl = result[0].url || result[0].link || result[0];
                }
                // C√°ch 6: result.success v√† result.data
                else if (result.success && result.data) {
                    imageUrl = result.data.url || result.data.link || result.data;
                }
            }
            
            if (imageUrl) {
                document.getElementById('imageLink').href = imageUrl;
                document.getElementById('imageLink').textContent = imageUrl;
                document.getElementById('result').classList.add('show');
                // Add to local history (default name 'j d√≥ #')
                try { addHistoryEntry(imageUrl); } catch(e) { console.warn('addHistoryEntry failed', e); }
            } else {
                showError('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c link ·∫£nh t·ª´ server! Response: ' + JSON.stringify(result));
                console.error('Full response:', result);
            }
        }

        // Hi·ªÉn th·ªã l·ªói
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
        }

        // ---------------- History (localStorage) ----------------
        const HISTORY_KEY = 'conversionHistory_v1';
        let conversionHistory = [];

        function loadHistory() {
            try {
                const raw = localStorage.getItem(HISTORY_KEY);
                conversionHistory = raw ? JSON.parse(raw) : [];
            } catch (e) {
                console.warn('Failed to load history', e);
                conversionHistory = [];
            }
            renderHistory();
        }

        function saveHistory() {
            try {
                localStorage.setItem(HISTORY_KEY, JSON.stringify(conversionHistory));
            } catch (e) {
                console.warn('Failed to save history', e);
            }
        }

        function addHistoryEntry(url) {
            const id = Date.now() + '_' + Math.floor(Math.random()*1000);
            const item = { id, url, createdAt: new Date().toISOString() };
            conversionHistory.unshift(item);
            // keep history bounded to 50 items
            if (conversionHistory.length > 50) conversionHistory = conversionHistory.slice(0,50);
            saveHistory();
            renderHistory();
        }

        function removeHistoryEntry(id) {
            conversionHistory = conversionHistory.filter(i=>i.id !== id);
            saveHistory();
            renderHistory();
        }

        // renameHistoryEntry removed ‚Äî history entries no longer have names

        function renderHistory() {
            const container = document.getElementById('historyList');
            if (!container) return;
            container.innerHTML = '';
            if (!conversionHistory || conversionHistory.length===0) {
                container.innerHTML = '<div style="color:#666">Ch∆∞a c√≥ l·ªãch s·ª≠.</div>';
                return;
            }
            conversionHistory.forEach(item => {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '8px';
                row.style.border = '1px solid #eee';
                row.style.padding = '8px';
                row.style.borderRadius = '6px';

                const thumb = document.createElement('img');
                thumb.src = item.url;
                thumb.style.width = '120px';
                thumb.style.height = 'auto';
                thumb.style.objectFit = 'cover';
                thumb.style.border = '1px solid #ddd';

                const meta = document.createElement('div');
                meta.style.flex = '1';

                const link = document.createElement('a');
                link.href = item.url;
                link.target = '_blank';
                link.innerText = item.url;
                link.style.display = 'block';
                link.style.fontSize = '12px';
                link.style.color = '#0066cc';

                const metaSmall = document.createElement('div');
                metaSmall.style.fontSize = '12px';
                metaSmall.style.color = '#666';
                metaSmall.innerText = new Date(item.createdAt).toLocaleString();

                meta.appendChild(link);
                meta.appendChild(metaSmall);

                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.flexDirection = 'column';
                actions.style.gap = '6px';

                const btnCopy = document.createElement('button');
                btnCopy.className = 'btn-choose-file';
                btnCopy.style.padding = '6px 8px';
                btnCopy.innerText = 'Copy link';
                btnCopy.addEventListener('click', ()=>{
                    navigator.clipboard.writeText(item.url).then(()=>alert('ƒê√£ sao ch√©p link!'));
                });

                const btnDelete = document.createElement('button');
                btnDelete.className = 'btn-choose-file';
                btnDelete.style.background = '#eee';
                btnDelete.style.padding = '6px 8px';
                btnDelete.innerText = 'X√≥a';
                btnDelete.addEventListener('click', ()=>{
                    if (confirm('X√≥a m·ª•c n√†y kh·ªèi l·ªãch s·ª≠?')) removeHistoryEntry(item.id);
                });

                actions.appendChild(btnCopy);
                actions.appendChild(btnDelete);

                row.appendChild(thumb);
                row.appendChild(meta);
                row.appendChild(actions);

                container.appendChild(row);
            });
        }

        // Initialize history on load
        try { loadHistory(); } catch(e){ console.warn('history init failed', e); }

        // Sao ch√©p link
        function copyLink() {
            const link = document.getElementById('imageLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                alert('ƒê√£ sao ch√©p link v√†o clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // ================= Normalization utilities =================
        function runNormalize() {
            const input = document.getElementById('normalizeInput').value || '';
            const smart = !!document.getElementById('smartRemove') && document.getElementById('smartRemove').checked;
            const resultEl = document.getElementById('normalizedResult');
            resultEl.textContent = '';
            const out = normalizeText(input, smart);
            resultEl.textContent = out;
        }

        function copyNormalized() {
            const out = document.getElementById('normalizedResult').textContent || '';
            if (!out) return alert('Ch∆∞a c√≥ k·∫øt qu·∫£ ƒë·ªÉ sao ch√©p');
            navigator.clipboard.writeText(out).then(()=>{
                alert('ƒê√£ sao ch√©p k·∫øt qu·∫£ chu·∫©n ho√°!');
            }).catch(err=>{
                console.error('Copy failed', err);
            });
        }

        // A heuristic normalizer: groups text into question blocks and ensures each option/answer on its own line.
        // smart: when true, try to remove section headers (I., II., "PH·∫¶N...", ALL CAPS headings) using heuristics
        function normalizeText(input, smart = true) {
            if (!input) return '';
            // Normalize line endings
            let s = input.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
            // Helper: decide if a single line is likely a heading/section title
            function isLikelyHeading(line) {
                if (!line) return false;
                const t = line.trim();
                // Lines that start with common instructional/descriptive prefixes
                if (/^\s*(D∆∞·ªõi ƒë√¢y|ƒê√¢y l√†|To√†n b·ªô|D∆∞·ªõi ƒë√¢y l√†|Below is|Here is)\b/i.test(t)) return true;
                // Lines that look like short instructions starting with 'A. Read' or 'Read then'
                if (/^\s*(A\.\s*Read|Read\b|ƒê·ªçc\b)/i.test(t)) return true;
                // Lines that mention API keys or integration notes are not question text
                if (/api\s*key|key\s*ƒë√£\s*ƒë∆∞·ª£c|private\s*mode|t√≠ch\s*h·ª£p\s*tr·ª±c\s*ti·∫øp/i.test(t)) return true;
                // If it contains keywords like PH·∫¶N, PART, SECTION it's almost certainly a heading
                if (/\b(PH·∫¶N|PART|SECTION|PH·∫¶N TR·∫ÆC NGHI·ªÜM|PH·∫¶N T·ª∞ LU·∫¨N|PH·∫¶N ƒê√öNG|PH·∫¶N ƒê√öNG\/SAI)\b/i.test(t)) return true;
                // Roman numeral at start (I., II., III.) followed by short text
                if (/^\s*[IVXLCDM]+\.\s*[^\n]{0,120}$/i.test(t)) return true;
                // If line is mostly uppercase letters and fairly short (likely a title)
                const letters = t.replace(/[^A-Za-z√Ä-·ªπ\u00C0-\u024F]/g,'');
                const uppers = letters.replace(/[^A-Z√Ä-·ª∏\u00C0-\u024F]/g,'');
                if (letters.length>0 && uppers.length/letters.length > 0.65 && t.split(/\s+/).length <= 10) return true;
                // Lines that are short and contain parentheses with uppercase (e.g. (READING & GRAMMAR))
                if (/\([^\)]{1,120}\)/.test(t) && /[A-Z&]{2,}/.test(t)) return true;
                return false;
            }

            // If smart removal enabled, prune obvious heading lines before other parsing
            if (smart) {
                const lines = s.split('\n');
                const kept = [];
                for (let i=0;i<lines.length;i++){
                    const line = lines[i];
                    if (isLikelyHeading(line)) {
                        // skip heading lines
                        continue;
                    }
                    // Also skip lines that are just single roman numerals like 'I.' or 'II.'
                    if (/^\s*[IVXLCDM]+\.\s*$/i.test(line)) continue;
                    kept.push(line);
                }
                s = kept.join('\n');
            }

            // Insert a blank line before 'C√¢u' if missing to help splitting
            s = s.replace(/\n(?=\s*C√¢u\s*\d+)/g, '\n');

            // Split into tentative blocks by 'C√¢u' or numbered lines
            let blocks = [];
            if (/C√¢u\s*\d+/i.test(s)) {
                const parts = s.split(/(?=C√¢u\s*\d+)/i);
                blocks = parts.map(p => p.trim()).filter(p=>p);
            } else {
                // fallback: split by blank lines
                blocks = s.split(/\n{2,}/).map(p=>p.trim()).filter(p=>p);
            }

            const normalized = [];
            let counter = 1;
            for (let blk of blocks) {
                // If block itself is just a section header like 'I. PH·∫¶N ...', skip it
                if (/^\s*[IVXLCDM]+\.\s*\bPH·∫¶N\b/i.test(blk)) continue;

                // If block starts like 'C√¢u 1. I. PH·∫¶N...' remove the embedded roman section after the C√¢u
                blk = blk.replace(/^(\s*C√¢u\s*\d+\.\s*)([IVXLCDM]+\.\s*\bPH·∫¶N\b[^\n]*)/i, '$1');
                // Also remove short descriptive fragments right after the 'C√¢u N.' prefix
                // e.g. 'C√¢u 1. D∆∞·ªõi ƒë√¢y l√†...' -> 'C√¢u 1.'
                blk = blk.replace(/^(\s*C√¢u\s*\d+\.\s*)(\s*(D∆∞·ªõi ƒë√¢y|ƒê√¢y l√†|D∆∞·ªõi ƒë√¢y l√†|To√†n b·ªô|Below is|Here is)\b[^\n]*)/i, '$1');

                // Pull out answer if inline
                let answerMatch = blk.match(/ƒê√°p √°n\s*[:\-]?\s*(.+)$/im);
                let answer = '';
                if (answerMatch) {
                    answer = answerMatch[1].trim();
                    // remove the matched tail from block
                    blk = blk.replace(/ƒê√°p √°n\s*[:\-]?\s*(.+)$/im, '').trim();
                }

                // Robustly split option labels. Handle variants: 'A.', 'A)', '(A)', lowercase 'a.' etc.
                blk = blk.replace(/(^|\n|\r|\s)\(?([A-Da-d])\)?[\.\)]\s*/g, function(_, pre, letter){
                    return '\n' + letter.toUpperCase() + '. ';
                });

                // Normalize line breaks and ensure a single space after label like 'A.'
                blk = blk.replace(/\n\s*/g,'\n');
                blk = blk.replace(/(^|\n)([A-D])\.(\s*)/g, '$1$2. ');

                // If block starts with a numeric '1.' replace it with 'C√¢u 1.'
                blk = blk.replace(/^\s*(\d+)\./, function(_,n){ return 'C√¢u '+n+'.'; });

                // Ensure block starts with 'C√¢u N.'; if not, add numbering sequentially
                if (!/^\s*C√¢u\s*\d+/i.test(blk)) {
                    blk = 'C√¢u '+(counter)+'. ' + blk;
                } else {
                    blk = blk.replace(/^\s*C√¢u\s*(\d+)\s*\.?\s*/i, function(_,n){ return 'C√¢u '+n+'. '; });
                }

                // Trim stray spaces
                blk = blk.split('\n').map(l=>l.trim()).filter(l=>l).join('\n');

                // Skip blocks that are only a bare 'C√¢u N.' with no question/options
                if (/^\s*C√¢u\s*\d+\.\s*$/i.test(blk)) continue;

                // Append answer line if we found one
                if (answer) {
                    blk = blk + '\nƒê√°p √°n: ' + answer;
                }

                normalized.push(blk);
                counter++;
            }

            return normalized.join('\n\n');
        }
    </script>
</body>
</html>
